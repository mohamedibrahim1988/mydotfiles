/* See LICENSE file for copyright and license details. */

/* Helper macros for spawning commands */
#define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
#define CMD(...)   { .v = (const char*[]){ __VA_ARGS__, NULL } }

/* appearance */
static const unsigned int borderpx = 2; /* border pixel of windows */
static const unsigned int snap = 32;    /* snap pixel */
static const unsigned int gappih = 5;   /* horiz inner gap between windows */
static const unsigned int gappiv = 10;  /* vert inner gap between windows */
static const unsigned int gappoh = 4; /* horiz outer gap between windows and screen edge */
static const unsigned int gappov = 2; /* vert outer gap between windows and screen edge */
static const int smartgaps_fact =1; /* gap factor when there is only one client; 0 = no gaps, 3 = 3x outer gaps */
static const char autostartblocksh[] = "autostart_blocking.sh";
static const char autostartsh[] = "autostart.sh";
static const char dwmdir[] = "dwm";
static const char localshare[] = ".local/share";
static const int showbar = 1; /* 0 means no bar */
static const int topbar = 1;  /* 0 means bottom bar */
static const int statusmon = 'A';
static const unsigned int systrayspacing = 2; /* systray spacing */
static const int showsystray = 1;             /* 0 means no systray */

/* Indicators: see patch/bar_indicators.h for options */
static int tagindicatortype = INDICATOR_BOTTOM_BAR;
static int tiledindicatortype = INDICATOR_NONE;
static int floatindicatortype = INDICATOR_TOP_LEFT_SQUARE;
static const char *fonts[] = { "JetBrainsMono Nerd Font:style=Medium:pixelsize=12",
    "Calibri:style=Bold:size=10:antialias=true:autohint=true",
};

static char c000000[] = "#c574dd"; // placeholder value

static char normbgcolor[] = "#1a1b26";
static char normbordercolor[] = "#1a1b26";
static char normfloatcolor[] = "#1a1b26";

static char selbordercolor[] = "#A5B4FC";
static char selfloatcolor[] = "#74c7ec";

static char titlenormbordercolor[] = "#1a1b26";
static char titlenormfloatcolor[] = "#74c7ec";

static char titleselbordercolor[] = "#9ECE6A";
static char titleselfloatcolor[] = "#9a7ecc";

static char tagsnormbordercolor[] = "#2b2f40";
static char tagsnormfloatcolor[] = "#1a1b26";

static char tagsselbordercolor[] = "#c574dd";
static char tagsselfloatcolor[] = "#c574dd";

static char urgfgcolor[] = "#a9b1d6";
static char urgbgcolor[] = "#1a1b26";
static char urgbordercolor[] = "#4ABAAF";
static char urgfloatcolor[] = "#1a1b26";

static char tag1fgcolor[] = "#f92672";
static char tag1bgcolor[] = "#1a1b26";
static char tag2fgcolor[] = "#a6e22e";
static char tag2bgcolor[] = "#1a1b26";
static char tag3fgcolor[] = "#f4bf75";
static char tag3bgcolor[] = "#1a1b26";
static char tag4fgcolor[] = "#66d9ef";
static char tag4bgcolor[] = "#1a1b26";
static char tag5fgcolor[] = "#ae81ff";
static char tag5bgcolor[] = "#1a1b26";
static char tag6fgcolor[] = "#f8f8f2";
static char tag6bgcolor[] = "#1a1b26";
static char tag7fgcolor[] = "#75715e";
static char tag7bgcolor[] = "#1a1b26";
static char tag8fgcolor[] = "#f4bf75";
static char tag8bgcolor[] = "#1a1b26";
static char tag9fgcolor[] = "#a1efe4";
static char tag9bgcolor[] = "#1a1b26";
static char layoutfgcolor[] = "#ae81ff";
static char layoutbgcolor[] = "#1a1b26";

static char *colors[][ColCount] = {
    /*                       fg                bg                border float */
    [SchemeNorm] = {"#F7768E", normbordercolor, normbordercolor, normfloatcolor},
    [SchemeSel] = {"#7AA2F7", normbgcolor, selbordercolor, selfloatcolor},
    [SchemeTitleNorm] = {"#39D7E5", normbordercolor, titlenormbordercolor,titlenormfloatcolor},
    [SchemeTitleSel] = {"#f92672", normbgcolor, titleselbordercolor, titleselfloatcolor},
    [SchemeTagsNorm] = {"#E0AF68", normbordercolor, tagsnormbordercolor, tagsnormfloatcolor},
    [SchemeTagsSel] = {"#C574DD", normbgcolor, tagsselbordercolor, tagsselfloatcolor},
    [SchemeHidNorm] = {"#7dcfff", normbordercolor, c000000, c000000},
    [SchemeHidSel] = {"#9ec07c", normbgcolor, c000000, c000000},
    [SchemeUrg] = {urgfgcolor, urgbgcolor, urgbordercolor, urgfloatcolor},
    [SchemeTag1] = {tag1fgcolor, tag1bgcolor, c000000},
    [SchemeTag2] = {tag2fgcolor, tag2bgcolor, c000000},
    [SchemeTag3] = {tag3fgcolor, tag3bgcolor, c000000},
    [SchemeTag4] = {tag4fgcolor, tag4bgcolor, c000000},
    [SchemeTag5] = {tag5fgcolor, tag5bgcolor, c000000},
    [SchemeTag6] = {tag6fgcolor, tag6bgcolor, c000000},
    [SchemeTag7] = {tag7fgcolor, tag7bgcolor, c000000},
    [SchemeTag8] = {tag8fgcolor, tag8bgcolor, c000000},
    [SchemeTag9] = {tag9fgcolor, tag9bgcolor, c000000},
    [SchemeLayout] = {layoutfgcolor, layoutbgcolor, c000000},
};

const char *spcmd1[] = {"st", "-n", "spterm", "-g", "120x34", NULL};
const char *spcmd2[] = {"st", "-n", "scratch2", "-e", "htop", NULL};
static Sp scratchpads[] = {
    /* name          cmd  */
    {"spterm", spcmd1},
    {"scratch2", spcmd2},
};

/* Tags
 * In a traditional dwm the number of tags in use can be changed simply by
 * changing the number of strings in the tags array. This build does things a
 * bit different which has some added benefits. If you need to change the number
 * of tags here then change the NUMTAGS macro in dwm.c.
 *
 * Examples:
 *
 *  1) static char *tagicons[][NUMTAGS*2] = {
 *         [DEFAULT_TAGS] = { "1", "2", "3", "4", "5", "6", "7", "8", "9", "A",
 * "B", "C", "D", "E", "F", "G", "H", "I" },
 *     }
 *
 *  2) static char *tagicons[][1] = {
 *         [DEFAULT_TAGS] = { "â€¢" },
 *     }
 *
 * The first example would result in the tags on the first monitor to be 1
 * through 9, while the tags for the second monitor would be named A through I.
 * A third monitor would start again at 1 through 9 while the tags on a fourth
 * monitor would also be named A through I. Note the tags count of NUMTAGS*2 in
 * the array initialiser which defines how many tag text / icon exists in the
 * array. This can be changed to *3 to add separate icons for a third monitor.
 *
 * For the second example each tag would be represented as a bullet point. Both
 * cases work the same from a technical standpoint - the icon index is derived
 * from the tag index and the monitor index. If the icon index is is greater
 * than the number of tag icons then it will wrap around until it an icon
 * matches. Similarly if there are two tag icons then it would alternate between
 * them. This works seamlessly with alternative tags and alttagsdecoration
 * patches.
 */
static char *tagicons[][NUMTAGS] = {
    [DEFAULT_TAGS] = {"1", "2", "3", "4", "5", "6", "7", "8", "9"},
    [ALTERNATIVE_TAGS] = {"A", "B", "C", "D", "E", "F", "G", "H", "I"},
    [ALT_TAGS_DECORATION] = {"<1>", "<2>", "<3>", "<4>", "<5>", "<6>", "<7>", "<8>", "<9>"},
};

/* There are two options when it comes to per-client rules:
 *  - a typical struct table or
 *  - using the RULE macro
 *
 * A traditional struct table looks like this:
 *    // class      instance  title  wintype  tags mask  isfloating  monitor
 *    { "Gimp",     NULL,     NULL,  NULL,    1 << 4,    0,          -1 },
 *    { "Firefox",  NULL,     NULL,  NULL,    1 << 7,    0,          -1 },
 *
 * The RULE macro has the default values set for each field allowing you to only
 * specify the values that are relevant for your rule, e.g.
 *
 *    RULE(.class = "Gimp", .tags = 1 << 4)
 *    RULE(.class = "Firefox", .tags = 1 << 7)
 *
 * Refer to the Rule struct definition for the list of available fields
 * depending on the patches you enable.
 */
static const Rule rules[] = {
RULE(.wintype = WTYPE "DIALOG", .isfloating = 1) 
RULE(.wintype = WTYPE "UTILITY", .isfloating = 1)
RULE(.wintype = WTYPE "TOOLBAR", .isfloating = 1) 
RULE(.wintype = WTYPE "SPLASH", .isfloating = 1)
RULE(.title = "Edit_Configs", .isfloating = 1, .iscentered = 1)
RULE(.class = "pavucontrol", .isfloating = 1, .iscentered = 1)
RULE(.class = "Qalculate-gtk", .isfloating = 1, .iscentered = 1)
RULE(.instance = "spterm", .tags = SPTAG(0), .isfloating = 1)
RULE(.instance = "scratch2", .tags = SPTAG(1), .isfloating = 1, .iscentered = 1)
RULE(.instance = "openvim", .tags = SPTAG(2), .isfloating = 1)
RULE(.instance = "network", .isfloating = 1, .iscentered = 1)
};

/* Bar rules allow you to configure what is shown where on the bar, as well as
 * introducing your own bar modules.
 *
 *    monitor:
 *      -1  show on all monitors
 *       0  show on monitor 0
 *      'A' show on active monitor (i.e. focused / selected) (or just -1 for
 * active?) bar - bar index, 0 is default, 1 is extrabar alignment - how the
 * module is aligned compared to other modules widthfunc, drawfunc, clickfunc -
 * providing bar module width, draw and click functions name - does nothing,
 * intended for visual clue and for logging / debugging
 */
static const BarRule barrules[] = {
	/* monitor   bar    alignment         widthfunc                 drawfunc                clickfunc                hoverfunc                name */
	{ -1,        0,     BAR_ALIGN_LEFT,   width_tags,               draw_tags,              click_tags,              hover_tags,              "tags" },
	{  0,        0,     BAR_ALIGN_RIGHT,  width_systray,            draw_systray,           click_systray,           NULL,                    "systray" },
	{ -1,        0,     BAR_ALIGN_LEFT,   width_ltsymbol,           draw_ltsymbol,          click_ltsymbol,          NULL,                    "layout" },
	{ statusmon, 0,     BAR_ALIGN_RIGHT,  width_status2d,           draw_status2d,          click_statuscmd,         NULL,                    "status2d" },
	{ -1,        0,     BAR_ALIGN_NONE,   width_wintitle,           draw_wintitle,          click_wintitle,          NULL,                    "wintitle" },
};

/* layout(s) */
static const float mfact = 0.5; /* factor of master area size [0.05..0.95] */
static const int nmaster = 1;   /* number of clients in master area */
static const int resizehints = 0; /* 1 means respect size hints in tiled resizals */
static const int lockfullscreen = 1; /* 1 will force focus on the fullscreen window */

static const Layout layouts[] = {
    /* symbol     arrange function */
    {"[]=", tile}, /* first entry is default */
    {"><>", NULL}, /* no layout function means floating behavior */
    {"[M]", monocle},
};

/* key definitions */
#define MODKEY Mod4Mask
#define TAGKEYS(KEY,TAG) \
	{ MODKEY,                       KEY,      view,           {.ui = 1 << TAG} }, \
	{ MODKEY|ControlMask,           KEY,      toggleview,     {.ui = 1 << TAG} }, \
	{ MODKEY|ShiftMask,             KEY,      tag,            {.ui = 1 << TAG} }, \
	{ MODKEY|ControlMask|ShiftMask, KEY,      toggletag,      {.ui = 1 << TAG} },


/* commands */
static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
static const char *dmenucmd[] = {"dmenu_run", "-m", dmenumon, NULL};
static const char *termcmd[] = {"alacritty", NULL};
static const char *filecmd[] = {"pcmanfm", NULL};
static const char *browsercmd[] = {"librewolf", NULL};

#include <X11/XF86keysym.h>
#include <X11/keysym.h>
/* This defines the name of the executable that handles the bar (used for
 * signalling purposes) */
#define STATUSBAR "dwmblocks"

static const Key keys[] = {
/* modifier                     key            function argument */
{MODKEY, XK_p, spawn, {.v = dmenucmd}},
{MODKEY, XK_Return, spawn, {.v = termcmd}},
{MODKEY, XK_Escape, spawn, SHCMD("xkill")},
{MODKEY, XK_e, spawn, {.v = filecmd}},
{MODKEY, XK_w, spawn, {.v = browsercmd}},
{0, XF86XK_AudioRaiseVolume, spawn, SHCMD("media-control up")},
{0, XF86XK_AudioLowerVolume, spawn, SHCMD("media-control down")},
{0, XF86XK_AudioMute, spawn, SHCMD("media-control mute")},
{0, XF86XK_AudioPrev, spawn, SHCMD("media-control prev")},
{0, XF86XK_AudioNext, spawn, SHCMD("media-control next")},
{0, XF86XK_AudioPlay, spawn, SHCMD("media-control toggle")},
{0, XF86XK_Search, spawn, SHCMD("media-control stop")},
{Mod1Mask | ControlMask, XK_o, spawn, SHCMD("picom-toggle.sh")},
{Mod1Mask, XK_Shift_L, spawn, SHCMD("change_kbd.sh")},
{MODKEY, XK_b, togglebar, {0}},
{MODKEY, XK_j, focusstack, {.i = +1}},
{MODKEY, XK_k, focusstack, {.i = -1}},
{MODKEY, XK_i, incnmaster, {.i = +1}},
{MODKEY, XK_d, incnmaster, {.i = -1}},
{MODKEY, XK_h, setmfact, {.f = -0.05}},
{MODKEY, XK_l, setmfact, {.f = +0.05}},
{MODKEY | ShiftMask, XK_j, movestack, {.i = +1}},
{MODKEY | ShiftMask, XK_k, movestack, {.i = -1}},
{MODKEY | ShiftMask, XK_Return, zoom, {0}},
{MODKEY | Mod1Mask, XK_u, incrgaps, {.i = +1}},
{MODKEY | Mod1Mask | ShiftMask, XK_u, incrgaps, {.i = -1}},
{MODKEY | Mod1Mask, XK_i, incrigaps, {.i = +1}},
{MODKEY | Mod1Mask | ShiftMask, XK_i, incrigaps, {.i = -1}},
{MODKEY | Mod1Mask, XK_o, incrogaps, {.i = +1}},
{MODKEY | Mod1Mask | ShiftMask, XK_o, incrogaps, {.i = -1}},
{MODKEY | Mod1Mask, XK_6, incrihgaps, {.i = +1}},
{MODKEY | Mod1Mask | ShiftMask, XK_6, incrihgaps, {.i = -1}},
{MODKEY | Mod1Mask, XK_7, incrivgaps, {.i = +1}},
{MODKEY | Mod1Mask | ShiftMask, XK_7, incrivgaps, {.i = -1}},
{MODKEY | Mod1Mask, XK_8, incrohgaps, {.i = +1}},
{MODKEY | Mod1Mask | ShiftMask, XK_8, incrohgaps, {.i = -1}},
{MODKEY | Mod1Mask, XK_9, incrovgaps, {.i = +1}},
{MODKEY | Mod1Mask | ShiftMask, XK_9, incrovgaps, {.i = -1}},
{MODKEY | Mod1Mask, XK_0, togglegaps, {0}},
{MODKEY | Mod1Mask | ShiftMask, XK_0, defaultgaps, {0}},
{MODKEY, XK_Tab, view, {0}},
{MODKEY, XK_q, killclient, {0}},
{MODKEY | ShiftMask, XK_q, quit, {0}},
{MODKEY | ControlMask | ShiftMask, XK_q, quit, {1}},
{MODKEY, XK_t, setlayout, {.v = &layouts[0]}},
{MODKEY, XK_n, setlayout, {.v = &layouts[1]}},
{MODKEY, XK_m, setlayout, {.v = &layouts[2]}},
{MODKEY, XK_space, setlayout, {0}},
{MODKEY | ShiftMask, XK_f, togglefloating, {0}},
{MODKEY, XK_grave, togglescratch, {.ui = 0}},
{MODKEY, XK_a, togglescratch, {.ui = 1}},
{MODKEY | ControlMask, XK_grave, setscratch, {.ui = 0}},
{MODKEY | ShiftMask, XK_grave, removescratch, {.ui = 0}},
{MODKEY, XK_f, togglefullscreen, {0}},
{MODKEY, XK_0, view, {.ui = ~SPTAGMASK}},
{MODKEY | ShiftMask, XK_0, tag, {.ui = ~SPTAGMASK}},
{MODKEY, XK_comma, focusmon, {.i = -1}},
{MODKEY, XK_period, focusmon, {.i = +1}},
{MODKEY | ShiftMask, XK_comma, tagmon, {.i = -1}},
{MODKEY | ShiftMask, XK_period, tagmon, {.i = +1}},
TAGKEYS(XK_1, 0) TAGKEYS(XK_2, 1) TAGKEYS(XK_3, 2) TAGKEYS(XK_4, 3)
TAGKEYS(XK_5, 4) TAGKEYS(XK_6, 5) TAGKEYS(XK_7, 6) TAGKEYS(XK_8, 7)
TAGKEYS(XK_9, 8)};

/* button definitions */
/* click can be ClkTagBar, ClkLtSymbol, ClkStatusText, ClkWinTitle,
 * ClkClientWin, or ClkRootWin */
static const Button buttons[] = {
    /* click                event mask           button          function
       argument */
    {ClkLtSymbol, 0, Button1, setlayout, {0}},
    {ClkLtSymbol, 0, Button3, setlayout, {.v = &layouts[2]}},
    {ClkWinTitle, 0, Button2, zoom, {0}},
    {ClkStatusText, 0, Button1, sigstatusbar, {.i = 1}},
    {ClkStatusText, ShiftMask, Button2, sigstatusbar, {.i = 2}},
    {ClkStatusText, 0, Button3, sigstatusbar, {.i = 3}},
    {ClkStatusText, 0, Button4, sigstatusbar, {.i = 4}},
    {ClkStatusText, 0, Button5, sigstatusbar, {.i = 5}},
    {ClkStatusText, 0, Button2, sigstatusbar, {.i = 6}},
    /* placemouse options, choose which feels more natural:
     *    0 - tiled position is relative to mouse cursor
     *    1 - tiled postiion is - view all windows on screen.relative to window center
     *    2 - mouse pointer warps to window center
     *
     * The moveorplace uses movemouse or placemouse depending on the floating
     * state of the selected client. Set up individual keybindings for the two
     * if you want to control these separately (i.e. to retain the feature to
     * move a tiled window into a floating position).
     */
    {ClkClientWin, MODKEY, Button1, moveorplace, {.i = 1}},
    {ClkClientWin, MODKEY, Button2, togglefloating, {0}},
    {ClkClientWin, MODKEY, Button3, resizemouse, {0}},
    {ClkTagBar, 0, Button1, view, {0}},
    {ClkTagBar, 0, Button3, toggleview, {0}},
    {ClkTagBar, MODKEY, Button1, tag, {0}},
    {ClkTagBar, MODKEY, Button3, toggletag, {0}},
};
